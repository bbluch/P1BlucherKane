Transcript File for this Project:
**We provided the LLM with P1.pdf and our github link to view our project**

the class is a 2d sparse matrix. I want to use two orthogonal arrays to represent the data
ChatGPT said:

Nice choice ðŸ‘ A 2D sparse matrix with orthogonal linked structure is a classic data structure.
Since you said "two orthogonal arrays," I think you want to build something like the cross-linked list representation (row headers and column headers, both pointing into the nonzero nodes).

Hereâ€™s a clean Java skeleton to get you started:

ðŸ”¹ SparseMatrix.java
package com.myproject.structures;

/**
 * SparseMatrix implemented with orthogonal linked lists.
 * Each non-zero element is stored in a Node, which is linked
 * both horizontally (across its row) and vertically (down its column).
 */
public class SparseMatrix {
    private int rows;
    private int cols;
    private Node[] rowHeaders;   // Array of row header nodes
    private Node[] colHeaders;   // Array of column header nodes

    // ðŸ”¹ Node class for each non-zero element
    private static class Node {
        int row;
        int col;
        int value;
        Node right;  // next element in the row
        Node down;   // next element in the column

        Node(int row, int col, int value) {
            this.row = row;
            this.col = col;
            this.value = value;
            this.right = null;
            this.down = null;
        }
    }

    // ðŸ”¹ Constructor
    public SparseMatrix(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;
        rowHeaders = new Node[rows];
        colHeaders = new Node[cols];
    }

    // ðŸ”¹ Insert a non-zero element
    public void insert(int row, int col, int value) {
        if (value == 0) return; // ignore zeros

        Node newNode = new Node(row, col, value);

        // Insert into row list
        if (rowHeaders[row] == null || rowHeaders[row].col > col) {
            newNode.right = rowHeaders[row];
            rowHeaders[row] = newNode;
        } else {
            Node current = rowHeaders[row];
            while (current.right != null && current.right.col < col) {
                current = current.right;
            }
            newNode.right = current.right;
            current.right = newNode;
        }

        // Insert into column list
        if (colHeaders[col] == null || colHeaders[col].row > row) {
            newNode.down = colHeaders[col];
            colHeaders[col] = newNode;
        } else {
            Node current = colHeaders[col];
            while (current.down != null && current.down.row < row) {
                current = current.down;
            }
            newNode.down = current.down;
            current.down = newNode;
        }
    }

    // ðŸ”¹ Get value at (row, col)
    public int get(int row, int col) {
        Node current = rowHeaders[row];
        while (current != null && current.col <= col) {
            if (current.col == col) {
                return current.value;
            }
            current = current.right;
        }
        return 0; // default for sparse entries
    }

    // ðŸ”¹ Print matrix (for debugging)
    public void printMatrix() {
        for (int i = 0; i < rows; i++) {
            Node current = rowHeaders[i];
            for (int j = 0; j < cols; j++) {
                if (current != null && current.col == j) {
                    System.out.print(current.value + " ");
                    current = current.right;
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
        }
    }
}


âœ… Features included in this skeleton:

Internal Node class with row/col/value + orthogonal links.

Row header array and column header array.

insert() maintains sorted order in both row and column.

get() retrieves values efficiently.

printMatrix() for debugging.

Do you want me to also add deletion of elements (removing a nonzero back to zero), or just keep insertion & retrieval for now?

use this picture to organize the code
(** picture of orthogonal list representation of a sparse matrix from the class notes on 15.1 **)
ChatGPT said:

Perfect ðŸ™Œ thanks for sharing that diagram. That figure shows the canonical orthogonal list sparse matrix (also called a cross-linked list):

Row header nodes in a linked list across the top.

Column header nodes in a linked list down the left.

Each nonzero element has four links (right, left, up, down).

Row headers link to the first nonzero element in that row.

Column headers link to the first nonzero element in that column.

Both row and column header lists are themselves circular or NULL-terminated depending on implementation.

Iâ€™ll restructure the Java code to mirror this picture:

ðŸ”¹ SparseMatrix.java
package com.myproject.structures;

/**
 * Orthogonal List Sparse Matrix Representation
 * Inspired by classic cross-linked structure diagrams.
 */
public class SparseMatrix {
    private int rows;
    private int cols;
    private HeaderNode rowHead; // linked list of row headers
    private HeaderNode colHead; // linked list of column headers

    // ðŸ”¹ Node for nonzero element
    private static class MatrixNode {
        int row, col, value;
        MatrixNode right, left, up, down;

        MatrixNode(int r, int c, int v) {
            this.row = r;
            this.col = c;
            this.value = v;
        }
    }

    // ðŸ”¹ Header node (for row/col headers)
    private static class HeaderNode {
        int index;              // row index OR column index
        HeaderNode next;        // next header in the linked list
        MatrixNode first;       // first nonzero in this row/col

        HeaderNode(int index) {
            this.index = index;
        }
    }

    // ðŸ”¹ Constructor
    public SparseMatrix(int rows, int cols) {
        this.rows = rows;
        this.cols = cols;

        // build row header list
        rowHead = new HeaderNode(-1); // dummy head
        HeaderNode prev = rowHead;
        for (int i = 0; i < rows; i++) {
            HeaderNode node = new HeaderNode(i);
            prev.next = node;
            prev = node;
        }

        // build col header list
        colHead = new HeaderNode(-1); // dummy head
        prev = colHead;
        for (int j = 0; j < cols; j++) {
            HeaderNode node = new HeaderNode(j);
            prev.next = node;
            prev = node;
        }
    }

    // ðŸ”¹ Insert a value
    public void insert(int row, int col, int value) {
        if (value == 0) return;
        MatrixNode newNode = new MatrixNode(row, col, value);

        // ---- Row insertion ----
        HeaderNode rHead = findRowHeader(row);
        if (rHead.first == null || rHead.first.col > col) {
            newNode.right = rHead.first;
            if (rHead.first != null) rHead.first.left = newNode;
            rHead.first = newNode;
        } else {
            MatrixNode current = rHead.first;
            while (current.right != null && current.right.col < col) {
                current = current.right;
            }
            newNode.right = current.right;
            if (current.right != null) current.right.left = newNode;
            current.right = newNode;
            newNode.left = current;
        }

        // ---- Column insertion ----
        HeaderNode cHead = findColHeader(col);
        if (cHead.first == null || cHead.first.row > row) {
            newNode.down = cHead.first;
            if (cHead.first != null) cHead.first.up = newNode;
            cHead.first = newNode;
        } else {
            MatrixNode current = cHead.first;
            while (current.down != null && current.down.row < row) {
                current = current.down;
            }
            newNode.down = current.down;
            if (current.down != null) current.down.up = newNode;
            current.down = newNode;
            newNode.up = current;
        }
    }

    // ðŸ”¹ Retrieve value
    public int get(int row, int col) {
        HeaderNode rHead = findRowHeader(row);
        MatrixNode current = rHead.first;
        while (current != null && current.col <= col) {
            if (current.col == col) return current.value;
            current = current.right;
        }
        return 0;
    }

    // ðŸ”¹ Print matrix
    public void printMatrix() {
        for (int i = 0; i < rows; i++) {
            HeaderNode rHead = findRowHeader(i);
            MatrixNode current = rHead.first;
            for (int j = 0; j < cols; j++) {
                if (current != null && current.col == j) {
                    System.out.print(current.value + " ");
                    current = current.right;
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
        }
    }

    // --- Helpers ---
    private HeaderNode findRowHeader(int row) {
        HeaderNode h = rowHead.next;
        while (h != null && h.index != row) h = h.next;
        return h;
    }

    private HeaderNode findColHeader(int col) {
        HeaderNode h = colHead.next;
        while (h != null && h.index != col) h = h.next;
        return h;
    }
}

âœ… How this matches your diagram:

Row headers (left) are a linked list of HeaderNode.

Column headers (top) are another linked list of HeaderNode.

Each nonzero cell (MatrixNode) has 4 links (left/right/up/down).

Insert keeps both row and column lists ordered.

This mirrors the orthogonal list structure in the picture exactly.

Do you want me to also implement a delete(row, col) so the list updates in both directions (unlinking from row & column simultaneously)?



/**

*

* @param row

* - row value (reviewer)

* @param col

* - column value (movie)

* @param val

* - review value (score)

*/

public void insert(int row, int col, int val) {

Node newNode = new Node(row, col, val);



// find header node for the row

HeaderNode headRow = findRowHeader(row);



// if there is no other node in that row OR

// if the first other node in the row is in a further column

if (headRow.nNode == null || headRow.nNode.col > col) {

// the new node becomes attached on the left to the first matrix

// node of the row

// headRow.nNode is null or another node further down the cols

newNode.right = headRow.nNode;

// if it is not the first entry in the row

if (headRow.nNode != null) {

headRow.nNode.left = newNode;

}

headRow.nNode = newNode;

}

// the node is either on the far right, or sandwiched between two

// existing nodes

else {

// a node used to track where the newNode goes

Node current = headRow.nNode;

}



} using this insert method we wrote, update it to improve it with the project 
specifications, while highlighting the specific changes made


Of course. I have updated your `insert` method to be fully functional according
 to the project specifications. Your original method correctly handled inserting
  a new rating at the beginning of a row, but it was missing the logic to insert
   a rating in the middle or at the end of a row, update an existing rating, and
    link the ratings vertically in columns.

Here is the improved `insert` method with the changes highlighted and explained.

### Improved `insert` Method

```java
    /**
     * Inserts a value at the specified row and column. If a node already
     * exists at this position, its value is updated.
     *
     * @param row - row value (reviewer)
     * @param col - column value (movie)
     * @param val - review value (score)
     */
    public void insert(int row, int col, int val) {
        Node newNode = new Node(row, col, val);

        // --- HORIZONTAL (ROW) INSERTION ---
        HeaderNode headRow = findRowHeader(row);
        Node currentRow = headRow.nNode;
        Node prevRow = null;

        // --- CHANGE 1 START ---
        // Traverse the row to find the correct position for the new node.
        // The original code only checked the first node. This loop finds the
        // correct position for insertion or finds an existing node to update.
        while (currentRow != null && currentRow.col < col) {
            prevRow = currentRow;
            currentRow = currentRow.right;
        }

        // If a node for this movie already exists, just update the score.
        if (currentRow != null && currentRow.col == col) {
            currentRow.value = val;
            return; // The node is updated, so we are done.
        }
        // --- CHANGE 1 END ---

        // Insert the new node into the row list
        newNode.left = prevRow;
        newNode.right = currentRow;
        if (prevRow != null) {
            prevRow.right = newNode;
        }
        else {
            headRow.nNode = newNode; // New first node for this row
        }
        if (currentRow != null) {
            currentRow.left = newNode;
        }


        // --- CHANGE 2 START ---
        // --- VERTICAL (COLUMN) INSERTION ---
        // The original method was missing this entire section. To conform to
        // the orthogonal list representation, each node must also be linked
        // vertically within its column.
        HeaderNode headCol = findColHeader(col);
        Node currentCol = headCol.nNode;
        Node prevCol = null;

        // Traverse the column to find the correct position for the new node
        while (currentCol != null && currentCol.row < row) {
            prevCol = currentCol;
            currentCol = currentCol.down;
        }

        // Insert the new node into the column list
        newNode.up = prevCol;
        newNode.down = currentCol;
        if (prevCol != null) {
            prevCol.down = newNode;
        }
        else {
            headCol.nNode = newNode; // New first node for this column
        }
        if (currentCol != null) {
            currentCol.up = newNode;
        }
        // --- CHANGE 2 END ---
    }
```

### Summary of Changes:

1.  **Complete Row Traversal and Update Logic:** Your original `else` block 
was empty. I've replaced it with a `while` loop that traverses the row's linked
 list to find the correct insertion point. [cite\_start]This ensures that new 
 ratings are always kept in ascending order by movie index, as required[cite: 441, 459].
  [cite\_start]It also now handles the case where a review for a given movie by a specific
   reviewer already exists, in which case it simply updates the score[cite: 441].
2.  **Added Vertical (Column) Linking:** The most significant addition is the 
entire second half of the method. Your original code did not link the new nodes
 vertically. The new code finds the correct column header and inserts the new node 
 into the column's linked list, maintaining ascending order by reviewer index. 
 [cite\_start]This is essential for the orthogonal list implementation specified 
 in the project description and will allow you to efficiently retrieve all ratings 
 for a given movie[cite: 447, 467].
 
 Could you write methods implemented in SparseMatrix to accomplish the logic
  needed for the delete methods?
 /**
     * Removes a single node (score) from the matrix at (row, col).
     * This method unlinks the node from both its row and column lists.
     *
     * @param row The row (reviewer) index
     * @param col The column (movie) index
     * @return True if a node was found and removed, false otherwise.
     */
    public boolean remove(int row, int col) {
        Node nodeToRemove = getNode(row, col);
        
        // Node does not exist, so nothing to remove
        if (nodeToRemove == null) {
            return false;
        }

        // Unlink from horizontal (row) list
        if (nodeToRemove.left != null) {
            // It's not the first node in the row
            nodeToRemove.left.right = nodeToRemove.right;
        }
        else {
            // It IS the first node, so update the row header
            findRowHeader(row).nNode = nodeToRemove.right;
        }
        if (nodeToRemove.right != null) {
            nodeToRemove.right.left = nodeToRemove.left;
        }

        // Unlink from vertical (column) list
        if (nodeToRemove.up != null) {
            // It's not the first node in the column
            nodeToRemove.up.down = nodeToRemove.down;
        }
        else {
            // It IS the first node, so update the column header
            findColHeader(col).nNode = nodeToRemove.down;
        }
        if (nodeToRemove.down != null) {
            nodeToRemove.down.up = nodeToRemove.up;
        }

        return true;
    }
    // --- NEW METHOD END ---


    // --- NEW METHOD START: removeRow ---
    /**
     * Removes an entire row (all ratings for a reviewer).
     * This iterates the row and unlinks each node from its respective column.
     *
     * @param row The row (reviewer) to remove.
     * @return True if the row had ratings and was removed, false if the
     * reviewer did not exist or had no ratings.
     */
    public boolean removeRow(int row) {
        HeaderNode headRow = findRowHeader(row);
        
        // If row doesn't exist or already has no ratings, return false.
        if (headRow == null || headRow.nNode == null) {
            return false;
        }

        Node curr = headRow.nNode;
        while (curr != null) {
            // For each node in the row, we must unlink it from its column list
            if (curr.up != null) {
                curr.up.down = curr.down;
            }
            else {
                // This node was the first in its column, update column header
                findColHeader(curr.col).nNode = curr.down;
            }
            
            if (curr.down != null) {
                curr.down.up = curr.up;
            }
            curr = curr.right; // Move to the next node in the row
        }

        // Finally, clear the row header's pointer, deleting the entire row list
        headRow.nNode = null;
        return true;
    }
    // --- NEW METHOD END ---


    // --- NEW METHOD START: removeCol ---
    /**
     * Removes an entire column (all ratings for a movie).
     * This iterates the column and unlinks each node from its respective row.
     *
     * @param col The column (movie) to remove.
     * @return True if the column had ratings and was removed, false if the
     * movie did not exist or had no ratings.
     */
    public boolean removeCol(int col) {
        HeaderNode headCol = findColHeader(col);

        // If col doesn't exist or already has no ratings, return false
        if (headCol == null || headCol.nNode == null) {
            return false;
        }

        Node curr = headCol.nNode;
        while (curr != null) {
            // For each node in the column, unlink it from its row list
            if (curr.left != null) {
                curr.left.right = curr.right;
            }
            else {
                // This node was the first in its row, update row header
                findRowHeader(curr.row).nNode = curr.right;
            }
            
            if (curr.right != null) {
                curr.right.left = curr.left;
            }
            curr = curr.down; // Move to the next node in the column
        }

        // Clear the column header's pointer, deleting the entire column list
        headCol.nNode = null;
        return true;
    }
    // --- NEW METHOD START: getNode (Helper) ---
    /**
     * Helper method to find and return a specific node at (row, col).
     * @param row The row index
     * @param col The col index
     * @return The Node at (row, col), or null if not found.
     */
    private Node getNode(int row, int col) {
        HeaderNode headRow = findRowHeader(row);
        if (headRow == null) {
            return null;
        }

        Node curr = headRow.nNode;
        // Traverse the row list (which is faster than traversing a column)
        while (curr != null && curr.col < col) {
            curr = curr.right;
        }

        // If we found the node at the exact column
        if (curr != null && curr.col == col) {
            return curr;
        }

        // Node doesn't exist
        return null;
    }
    // --- NEW METHOD END ---
    
    Write tests to cover the remove methods
    
    This is an excellent way to test, as the delete methods contain the most complex pointer logic and are prime targets for mutation.

A mutant will try to do things like:

Forget to unlink a node from its row, or forget to unlink it from its column.

Fail to update the nNode pointer in the header if the node being deleted is the first node in a list.

Return true even when no node was found to delete.

In removeRow, a mutant might delete the row list but forget to iterate and unlink each node from its respective column (and vice-versa for removeCol).

Here are the specific test methods you should add to your MovieRaterTest.java file to kill these mutants.

Note: These tests assume you have implemented the remove, removeRow, and removeCol methods in SparseMatrix.java as provided in my previous answers, and that MovieRaterDB.java correctly calls them.

Tests for deleteScore()
This tests the remove(row, col) method in your matrix.

/**
     * Tests deleting a score that does not exist.
     */
    public void testDeleteScoreNonExistent() {
        it.addReview(5, 5, 5);
        assertFalse(it.deleteScore(99, 99)); // Neither exists
        assertFalse(it.deleteScore(5, 99));  // Row exists, col doesn't
        assertFalse(it.deleteScore(99, 5));  // Col exists, row doesn't
    }

    /**
     * Tests deleting a single score that is the only item in its
     * row AND column. This specifically tests the header pointer updates.
     */
    public void testDeleteOnlyScore() {
        it.addReview(1, 1, 1);
        assertTrue(it.deleteScore(1, 1));
        assertNull(it.listReviewer(1)); // listReviewer returns null for no ratings
        assertNull(it.listMovie(1));
        assertEquals("", it.printRatings());
    }

    /**
     * Tests deleting a score that is in the MIDDLE of a row and column list.
     * This tests the core "prev.next = curr.next" pointer logic.
     */
    public void testDeleteScoreInMiddle() {
        // Setup: (5,5) will be in the middle of its row and col
        it.addReview(5, 2, 1);
        it.addReview(5, 5, 2);
        it.addReview(5, 8, 3);

        it.addReview(2, 5, 4);
        it.addReview(8, 5, 6);

        // Pre-check
        assertEquals("5: 1 2 3", it.listReviewer(5));
        assertEquals("5: 4 2 6", it.listMovie(5));

        // Action: Delete the middle node
        assertTrue(it.deleteScore(5, 5));

        // Verify: Both lists should be correctly relinked
        assertEquals("5: 1 3", it.listReviewer(5)); // Row is relinked
        assertEquals("5: 4 6", it.listMovie(5)); // Column is relinked
    }
    
    /**
     * Tests deleting a score that is the FIRST in its row, but not its col.
     */
    public void testDeleteScoreFirstInRow() {
        it.addReview(5, 2, 1); // Node to delete
        it.addReview(5, 5, 2);
        it.addReview(1, 2, 9); // Node before it in the column

        assertTrue(it.deleteScore(5, 2));
        assertEquals("5: 2", it.listReviewer(5)); // Row header updated
        assertEquals("2: 9", it.listMovie(2));    // Column relinked
    }

    /**
     * Tests deleting a score that is the FIRST in its column, but not its row.
     */
    public void testDeleteScoreFirstInCol() {
        it.addReview(5, 2, 1); 
        it.addReview(5, 5, 2); // Node to delete
        it.addReview(1, 5, 9); // Node before it in the row
        
        assertTrue(it.deleteScore(5, 5));
        assertEquals("5: 1", it.listReviewer(5));   // Row relinked
        assertEquals("5:", it.listMovie(5));      // Col header updated (no ratings left)
    }
    
    
Tests for deleteReviewer()
This tests the removeRow(row) method in your matrix. The critical test here 
must verify that column integrity is maintained.
/**
     * Tests deleting a reviewer that has no ratings (or doesn't exist).
     */
    public void testDeleteNonExistentReviewer() {
        it.addReview(1, 1, 5); // Add some other data
        assertFalse(it.deleteReviewer(99)); // Doesn't exist
        
        // Reviewer 5 exists (header created) but has no nodes
        it.addReview(5, 1, 5); 
        it.deleteScore(5, 1);
        assertFalse(it.deleteReviewer(5)); // Row exists but is empty
    }

    /**
     * Tests deleting a reviewer and verifies that all associated column lists
     * are correctly unlinked. This is the main test for removeRow.
     */
    public void testDeleteReviewerFull() {
        // Add ratings for the reviewer to be deleted (Reviewer 10)
        it.addReview(10, 5, 1);  // This node is between 8 and 12 in its col
        it.addReview(10, 10, 2); // This node is first in its col
        it.addReview(10, 15, 3); // This node is last in its col

        // Add nodes *around* the ones we are about to delete
        it.addReview(8, 5, 9);   // Before (10, 5)
        it.addReview(12, 5, 9);  // After (10, 5)
        
        it.addReview(11, 10, 9); // After (10, 10)
        
        it.addReview(1, 15, 9);  // Before (10, 15)

        // Verify pre-conditions
        assertEquals("10: 1 2 3", it.listReviewer(10));
        assertEquals("5: 9 1 9", it.listMovie(5));
        assertEquals("10: 2 9", it.listMovie(10));
        assertEquals("15: 9 3", it.listMovie(15));
        
        // Action: Delete the entire reviewer
        assertTrue(it.deleteReviewer(10));

        // Verify all traces are gone
        assertNull(it.listReviewer(10)); // The row is gone
        
        // Verify column integrity (this kills the mutants)
        assertEquals("5: 9 9", it.listMovie(5));   // Middle node unlinked
        assertEquals("10: 9", it.listMovie(10)); // Head node unlinked
        assertEquals("15: 9", it.listMovie(15)); // Tail node unlinked
    }
    
Tests for deleteMovie()
This tests the removeCol(col) method. This is the mirror image of the 
deleteReviewer test and is just as important.

/**
     * Tests deleting a movie that has no ratings (or doesn't exist).
     */
    public void testDeleteNonExistentMovie() {
        it.addReview(1, 1, 5);
        assertFalse(it.deleteMovie(99)); // Doesn't exist
        
        // Movie 5 exists (header created) but has no nodes
        it.addReview(1, 5, 5); 
        it.deleteScore(1, 5);
        assertFalse(it.deleteMovie(5)); // Col exists but is empty
    }

    /**
     * Tests deleting a movie and verifies that all associated row lists
     * are correctly unlinked. This is the main test for removeCol.
     */
    public void testDeleteMovieFull() {
        // Add ratings for the movie to be deleted (Movie 10)
        it.addReview(5, 10, 1);  // This node is between 8 and 12 in its row
        it.addReview(10, 10, 2); // This node is first in its row
        it.addReview(15, 10, 3); // This node is last in its row

        // Add nodes *around* the ones we are about to delete
        it.addReview(5, 8, 9);   // Before (5, 10)
        it.addReview(5, 12, 9);  // After (5, 10)
        
        it.addReview(10, 11, 9); // After (10, 10)
        
        it.addReview(15, 1, 9);  // Before (15, 10)

        // Verify pre-conditions
        assertEquals("10: 1 2 3", it.listMovie(10));
        assertEquals("5: 9 1 9", it.listReviewer(5));
        assertEquals("10: 2 9", it.listReviewer(10));
        assertEquals("15: 9 3", it.listReviewer(15));
        
        // Action: Delete the entire movie
        assertTrue(it.deleteMovie(10));

        // Verify all traces are gone
        assertNull(it.listMovie(10)); // The col is gone
        
        // Verify row integrity (this kills the mutants)
        assertEquals("5: 9 9", it.listReviewer(5));   // Middle node unlinked
        assertEquals("10: 9", it.listReviewer(10)); // Head node unlinked
        assertEquals("15: 9", it.listReviewer(15)); // Tail node unlinked
    }
    
Could you also implement the similarMovie and similarReviewer methods? 
I only need the methods, not the entire files    
    
This is the most complex part of the assignment. To implement these methods,
 you must:

Add accessor methods to SparseMatrix.java: You need a way to get the start 
of the row and column header lists so you can iterate over all reviewers and movies.

Implement private helper methods in MovieRaterDB.java: You need helper 
methods to calculate the similarity score between two reviewers and two movies.

Implement the public methods in MovieRaterDB.java: These methods will use 
the helpers to loop through all other reviewers/movies, track the best score,
and return the correct index.

Here are all the new and updated methods you will need.

/**
     * Gets the main row header node (the start of the header list, index 0).
     * @return the rowHeader (header for index 0)
     */
    public HeaderNode getRowHeaderList() {
        return rowHeader;
    }

    /**
     * Gets the main col header node (the start of the header list, index 0).
     * @return the colHeader (header for index 0)
     */
    public HeaderNode getColHeaderList() {
        return colHeader;
    }
    
// ----------------------------------------------------------
    /**
     * Return the index for the movie most similar to the specified one.
     [cite_start]* [cite: 22]
     * @param movie the movie to find match for.
     * @return The best matching index.
     * Return -1 if this movie does not exist or if there is no
     * suitable match
     */
    public int similarMovie(int movie) {
        // 1. Get the target movie's column data
        SparseMatrix.HeaderNode targetHeader = matrix.findColHeader(movie);
        
        // Return -1 if movie doesn't exist or has no ratings
        if (targetHeader == null || targetHeader.nNode == null) {
            return -1; 
        }
        SparseMatrix.Node targetColNodes = targetHeader.nNode;

        int bestMovieId = -1;
        double lowestScore = Double.MAX_VALUE;

        // 2. Iterate through EVERY OTHER movie in the database
        SparseMatrix.HeaderNode otherHeader = matrix.getColHeaderList();
        while (otherHeader != null) {
            // Skip if it's the same movie or if the other movie has no ratings
            if (otherHeader.index != movie && otherHeader.nNode != null) {
                
                // 3. Calculate the similarity score
                double score = calculateMovieSimilarity(
                    targetColNodes, otherHeader.nNode);

                // 4. Track the best score (lowest positive score wins)
                [cite_start]if (score != -1.0) { // Score of -1 means no shared reviewers [cite: 21]
                    if (score < lowestScore) {
                        lowestScore = score;
                        bestMovieId = otherHeader.index;
                    }
                    // Tie-breaker: If scores are equal, choose the movie with the lower index
                    else if (score == lowestScore) {
                        bestMovieId = Math.min(bestMovieId, otherHeader.index);
                    }
                }
            }
            otherHeader = otherHeader.n; // Move to the next movie
        }

        return bestMovieId; // Will be -1 if no suitable match was found
    }


    // ----------------------------------------------------------
    /**
     * Return the index for the reviewer most similar to the specified one.
     [cite_start]* [cite: 16]
     * @param reviewer the reviewer to find match for.
     * @return The best matching index.
     * Return -1 if this reviewer does not exist or if there is no
     * suitable match
     */
    public int similarReviewer(int reviewer) {
        // 1. Get the target reviewer's row data
        SparseMatrix.HeaderNode targetHeader = matrix.findRowHeader(reviewer);
        
        // Return -1 if reviewer doesn't exist or has no ratings
        if (targetHeader == null || targetHeader.nNode == null) {
            return -1;
        }
        SparseMatrix.Node targetRowNodes = targetHeader.nNode;

        int bestReviewerId = -1;
        double lowestScore = Double.MAX_VALUE;

        [cite_start]// 2. Iterate through EVERY OTHER reviewer in the database [cite: 17]
        SparseMatrix.HeaderNode otherHeader = matrix.getRowHeaderList();
        while (otherHeader != null) {
            // Skip if it's the same reviewer or has no ratings
            if (otherHeader.index != reviewer && otherHeader.nNode != null) {
                
                // 3. Calculate similarity score
                double score = calculateReviewerSimilarity(
                    targetRowNodes, otherHeader.nNode);

                [cite_start]// 4. Track the best score (lowest positive score wins) [cite: 20]
                [cite_start]if (score != -1.0) { // Score of -1 means no shared movies [cite: 21]
                    if (score < lowestScore) {
                        lowestScore = score;
                        bestReviewerId = otherHeader.index;
                    }
                    // Tie-breaker: If scores are equal, choose the reviewer with the lower index
                    else if (score == lowestScore) {
                        bestReviewerId = Math.min(bestReviewerId, otherHeader.index);
                    }
                }
            }
            otherHeader = otherHeader.n; // Move to the next reviewer
        }

        return bestReviewerId; // Will be -1 if no suitable match was found
    }

    
    /**
     * Private helper to calculate similarity score between two reviewers.
     * Iterates both row lists simultaneously to find matching movies.
     * @param rowX Node list for Reviewer X
     * @param rowY Node list for Reviewer Y
     * [cite_start]@return The similarity score, or -1.0 if no movies are shared. [cite: 21]
     */
    private double calculateReviewerSimilarity(SparseMatrix.Node rowX, SparseMatrix.Node rowY) {
        double totalDiff = 0;
        int sharedCount = 0;
        SparseMatrix.Node currX = rowX;
        SparseMatrix.Node currY = rowY;

        while (currX != null && currY != null) {
            if (currX.col < currY.col) {
                currX = currX.right; // Movie rated by X, not Y
            }
            else if (currY.col < currX.col) {
                currY = currY.right; // Movie rated by Y, not X
            }
            else {
                [cite_start]// Shared movie found! [cite: 18]
                totalDiff += Math.abs(currX.value - currY.value); [cite_start]// [cite: 18]
                sharedCount++; [cite_start]// [cite: 19]
                currX = currX.right;
                currY = currY.right;
            }
        }

        if (sharedCount == 0) {
            return -1.0; [cite_start]// Per spec, score is -1 if no movies are shared [cite: 21]
        }

        return totalDiff / sharedCount; [cite_start]// [cite: 19]
    }

    
    /**
     * Private helper to calculate similarity score between two movies.
     * Iterates both column lists simultaneously to find matching reviewers.
     * @param colA Node list for Movie A
     * @param colB Node list for Movie B
     * @return The similarity score, or -1.0 if no reviewers are shared.
     */
    private double calculateMovieSimilarity(SparseMatrix.Node colA, SparseMatrix.Node colB) {
        double totalDiff = 0;
        int sharedCount = 0;
        SparseMatrix.Node currA = colA;
        SparseMatrix.Node currB = colB;

        while (currA != null && currB != null) {
            if (currA.row < currB.row) {
                currA = currA.down; // Reviewer rated A, not B
            }
            else if (currB.row < currA.row) {
                currB = currB.down; // Reviewer rated B, not A
            }
            else {
                // Shared reviewer found!
                totalDiff += Math.abs(currA.value - currB.value);
                sharedCount++;
                currA = currA.down;
                currB = currB.down;
            }
        }

        if (sharedCount == 0) {
            return -1.0; [cite_start]// Per spec, score is -1 if no reviewers are shared [cite: 21]
        }

        return totalDiff / sharedCount;
    }